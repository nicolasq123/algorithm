1. 空切片与nil切片的区别
    - 1.nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0 
    - 2.空切片的引用数组指针地址是有的，且固定为一个值
2. 字符串转成byte数组，会发生内存拷贝吗
    - 会, 底层结构不一样，需要用unsafe.Pointer转

```
type StringHeader struct {
 Data uintptr
 Len  int
}
```
3. 翻转含有中文、数字、英文字母的字符串
    - str强转[]rune
4. 拷贝大切片一定比小切片代价大吗
    - 一样
```
type SliceHeader struct {
 Data uintptr
 Len  int
 Cap  int
}
```

5. map的iterator是否安全？能不能一边delete一边遍历
   - 安全， 能。删除操作仅仅将对应的tophash[i]设置为empty，并非释放内存。

6. closed 状态的chann是读安全的，写会panic
7. 向nil 值状态的chann 读写，都会永远阻塞
8. 方法接收者是类型（T），接收者只是原对象的值复制，在方法中修改接收者不会修改原始对象的值；如果方法接收者是指针类型（*T），是对原对象的引用，方法中对其修改当然是原对象修改。
```
type data struct {
	num   int
	key   *string
	items map[string]bool // 引用类型，所以副本也可以修改
}

func (this *data) pmethod() {
	this.num = 7
}

func (this data) vmethod() {
	this.num = 8
	*this.key = "xxx"
	this.items["vmethod"] = true
}
```
9. 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。
10. json包变量不加tag会怎么样
    - 小写private不处理
    - 无tag就是变量名，有tag使用tag
11. 切片初始化
    - make([]type, len)  make([]type, len， cap)
    - s := make([]int, 10) 零切片
    - var s1 []int; var s2 = []int{}; var s3 = make([]int, 0); var s4 = *new([]int); s1 s4nil切片， s2 s3空切片
12. map触发扩容的时机，满足什么条件时扩容
    - 装载因子超过阈值，源码里定义的阈值是 6.5 （元素太多，需要扩容。 此情况新bucket*2）
    - overflow 的 bucket 数量过多 （拉链法hashtable， 防止退化成链表。 开辟新bucket空间）
13. map扩容策略是什么
    - 比较复杂，渐进式把旧bucket数据搬迁到新bucket
14. 为什么遍历 map 是无序的
    - map扩容后，发生搬迁，顺序就变了
    - 新老bukcet搬迁，map会处于一个中间未搬迁完的中间状态
    - 每次都是从一个随机值序号的 bucket 开始遍历（go机制， 防止误解），使你是一个写死的map，遍历顺序也是随机的
15. map操作 （https://zhuanlan.zhihu.com/p/66676224）
    - range
    - update/insert
    - delete,找到对应位置后，对 key 或者 value 进行“清零”操作. 将count--
    - 边遍历边写，或者边遍历边删除，会panic
16. golang slice (https://www.cnblogs.com/qcrao-2018/p/10631989.html)
17. 